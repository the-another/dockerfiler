# Cursor Instructions for Dockerfile Generator CLI

## Project Overview

This is a pure TypeScript CLI tool for generating hardened, multi-architecture Docker images for web server setups with Nginx and PHP. The system automatically handles ARM64 and AMD64 architectures while maintaining platform-specific configurations for Alpine and Ubuntu.

## Core Development Principles

### 1. Pure TypeScript Implementation

- **NO FRAMEWORKS**: Use only pure TypeScript and Node.js APIs
- **Latest Versions**: Always use the latest stable versions of all dependencies
- **Performance First**: Optimize for speed and efficiency in CI/CD environments
- **Type Safety**: Maintain 100% TypeScript type coverage

### 2. Architecture Guidelines

- **Flat Command Structure**: Use colon delimiters (e.g., `build:image`, `deploy:matrix`)
- **Service-Oriented**: Organize code into focused services (Template Engine, Security Engine, etc.)
- **Configuration Inheritance**: Implement hierarchical configuration with platform-specific overrides
- **Multi-Architecture Support**: Generate both ARM64 and AMD64 variants automatically

### 3. Security by Default

- **No Security Options**: Security features are always enabled, no way to disable
- **Hardened Configurations**: Implement security best practices in all generated outputs
- **Input Validation**: Validate and sanitize all inputs at multiple levels
- **Security Scanning**: Include built-in vulnerability detection

## Project Structure

```
src/
├── cli/           # CLI entry point and argument parsing
├── commands/      # Command implementations (build:, deploy:, test:, validate:)
├── services/      # Core business logic services
├── configs/       # Configuration files and interfaces
├── templates/     # Handlebars templates
├── types/         # TypeScript type definitions
└── utils/         # Utility functions

tests/
├── unit/          # Unit tests with comprehensive coverage
├── integration/   # Integration tests
└── fixtures/      # Test data and fixtures

docs/              # Project documentation
scripts/           # Build and deployment scripts
output/            # Generated Dockerfiles (gitignored)
```

## Coding Standards

### 1. TypeScript Best Practices

```typescript
// Always use strict TypeScript configuration
// Use interfaces for object shapes, types for unions/primitives
interface BaseConfig {
  php: PHPConfig;
  security: SecurityConfig;
  nginx: NginxConfig;
}

// Use generic types for reusable components
class ConfigLoader<T extends BaseConfig> {
  load(path: string): Promise<T> {
    /* ... */
  }
}

// Prefer readonly properties where possible
interface SecurityConfig {
  readonly user: string;
  readonly group: string;
  readonly nonRoot: boolean;
}

// Export statements - NEVER use file extensions
export * from './service/php-fpm-config'; // ✅ Correct
export * from './service/php-fpm-config.js'; // ❌ Wrong - no extensions
export { PHPConfig } from './service/php-config'; // ✅ Correct
export { PHPConfig } from './service/php-config.ts'; // ❌ Wrong - no extensions

// Import statements - Use @/ alias when possible
import { ErrorType, ErrorSeverity } from '@/types'; // ✅ Correct - use @/ alias
import { BaseConfig } from '@/types/configs'; // ✅ Correct - use @/ alias
import { PHPConfig } from './service/php-config'; // ✅ Correct - relative for same directory
import { PHPConfig } from '../types/configs/service/php-config'; // ❌ Wrong - use @/ instead
```

### 2. Error Handling

```typescript
// Use custom error classes with typed error types
export class DockerfileGeneratorError extends Error {
  constructor(
    public type: ErrorType,
    message: string,
    public details?: any,
    public suggestions?: string[]
  ) {
    super(message);
    this.name = 'DockerfileGeneratorError';
  }
}

// Always provide helpful error messages and suggestions
throw new DockerfileGeneratorError(
  'CONFIG_LOAD_ERROR',
  'Failed to load configuration file',
  { filePath: configPath, error: err.message },
  ['Check file permissions', 'Verify file format', 'Ensure file exists']
);
```

### 3. Configuration Management

```typescript
// Use Joi for schema validation
const baseConfigSchema = Joi.object({
  php: Joi.object({
    version: Joi.string()
      .pattern(/^[78]\.[0-4]$/)
      .required(),
    extensions: Joi.array().items(Joi.string()).min(1).required(),
  }).required(),
});

// Implement configuration inheritance
class ConfigManager {
  mergeConfigs(base: BaseConfig, platform: PlatformConfig): FinalConfig {
    return { ...base, ...platform };
  }
}
```

### 4. Template System

```typescript
// Use Handlebars with custom helpers
Handlebars.registerHelper('eq', function (a, b) {
  return a === b;
});

// Keep templates architecture-agnostic
// Platform-specific logic should be in configuration, not templates
```

## Command Implementation Guidelines

### 1. Command Structure

```typescript
// All commands should follow this pattern
export class BuildImageCommand implements Command {
  async execute(args: BuildImageArgs): Promise<void> {
    try {
      // 1. Validate arguments
      this.validateArgs(args);

      // 2. Load configuration
      const config = await this.loadConfig(args);

      // 3. Generate matrix
      const matrix = this.generateMatrix(config);

      // 4. Process each variant
      await this.processVariants(matrix);

      // 5. Success output
      this.outputSuccess(matrix);
    } catch (error) {
      this.handleError(error);
    }
  }
}
```

### 2. Argument Validation

```typescript
// Always validate arguments before processing
private validateArgs(args: BuildImageArgs): void {
  if (args.php && !this.isValidPHPVersion(args.php)) {
    throw new DockerfileGeneratorError(
      'VALIDATION_ERROR',
      `Invalid PHP version: ${args.php}`,
      { version: args.php },
      ['Supported versions: 7.4, 8.0, 8.1, 8.2, 8.3, 8.4']
    );
  }
}
```

## Testing Requirements

### 1. Test Coverage

- **Minimum 95% coverage** for all new code
- **Unit tests** for all services and utilities
- **Integration tests** for command workflows
- **Test fixtures** for realistic test scenarios

### 2. Test Structure

```typescript
// Always include descriptive comments explaining test purpose
describe('ConfigManager', () => {
  describe('mergeConfigs', () => {
    it('should merge base config with platform overrides', () => {
      // Test merges base configuration with platform-specific overrides
      // ensuring platform settings take precedence over base settings
      const base = createBaseConfig();
      const platform = createPlatformConfig();

      const result = configManager.mergeConfigs(base, platform);

      expect(result.php.version).toBe(platform.php.version);
      expect(result.security.user).toBe(base.security.user);
    });
  });
});
```

### 3. Test Data

```typescript
// Use realistic test fixtures
const createTestConfig = (): BaseConfig => ({
  php: {
    version: '8.3',
    extensions: ['mbstring', 'xml', 'curl'],
    fpm: {
      maxChildren: 50,
      startServers: 5,
      minSpareServers: 5,
      maxSpareServers: 35,
    },
  },
  security: {
    user: 'www-data',
    group: 'www-data',
    nonRoot: true,
    readOnlyRoot: true,
    capabilities: ['CHOWN', 'SETGID', 'SETUID'],
  },
});
```

## Performance Guidelines

### 1. Optimization Targets

- **Startup time**: < 100ms
- **Config loading**: < 50ms
- **Template rendering**: < 100ms
- **File generation**: < 500ms
- **Memory usage**: < 50MB
- **CPU usage**: < 10%

### 2. Performance Strategies

```typescript
// Use lazy loading for configurations
class ConfigLoader {
  private cache = new Map<string, BaseConfig>();

  async load(path: string): Promise<BaseConfig> {
    if (this.cache.has(path)) {
      return this.cache.get(path)!;
    }

    const config = await this.loadFromFile(path);
    this.cache.set(path, config);
    return config;
  }
}

// Implement parallel processing for matrix generation
async processVariants(matrix: VariantMatrix): Promise<void> {
  const promises = matrix.variants.map(variant =>
    this.processVariant(variant)
  );

  await Promise.all(promises);
}
```

## Security Implementation

### 1. Security Features

- **Non-root user execution**
- **Read-only root filesystem**
- **Capability dropping**
- **Package validation**
- **Input sanitization**
- **Template sandboxing**

### 2. Security Validation

```typescript
// Always validate security configurations
class SecurityValidator {
  validateConfig(config: SecurityConfig): void {
    if (!config.nonRoot) {
      throw new SecurityError('Non-root execution is mandatory');
    }

    if (!config.readOnlyRoot) {
      throw new SecurityError('Read-only root is mandatory');
    }
  }
}
```

## File Generation Guidelines

### 1. Output Structure

```
output/
├── nginx-php-fpm-8.4-alpine/
│   ├── arm64/
│   │   ├── Dockerfile
│   │   ├── nginx.conf
│   │   ├── php-fpm.conf
│   │   └── s6-overlay/
│   └── amd64/
│       └── [same structure]
```

### 2. File Validation

```typescript
// Validate generated files before writing
class FileValidator {
  validateDockerfile(content: string): void {
    if (!content.includes('FROM')) {
      throw new ValidationError('Dockerfile missing FROM instruction');
    }

    if (!content.includes('USER')) {
      throw new ValidationError('Dockerfile missing USER instruction');
    }
  }
}
```

## Development Workflow

### 1. Before Writing Code

- **Read the implementation plan** in `docs/implementation-plan.md`
- **Review system architecture** in `docs/system-architecture.md`
- **Understand the command structure** and flow
- **Check existing implementations** for patterns

### 2. Scope Control When Using Implementation Plan

- **ALWAYS LIMIT SCOPE** to the specific implementation plan point being worked on
- **NO SCOPE CREEP**: Do not implement additional features beyond what's requested
- **Single Point Focus**: If implementing Phase X.Y.Z, focus ONLY on that specific task
- **Avoid Unrelated Changes**: Do not refactor, optimize, or add features not in the current scope
- **Clear Boundaries**: Each implementation plan point should be a discrete, focused piece of work
- **Navigation Friendly**: Changes should be predictable and limited to prevent confusion

### 3. Code Review Checklist

- [ ] Follows pure TypeScript principles (no frameworks)
- [ ] Includes comprehensive error handling
- [ ] Has proper TypeScript types and interfaces
- [ ] Includes unit tests with descriptive comments
- [ ] Follows security-by-default principles
- [ ] Optimized for performance targets
- [ ] Handles multi-architecture scenarios

### 4. Testing Before Commit

```bash
# Run all tests
pnpm test

# Run specific test suites
pnpm test:unit
pnpm test:integration

# Check test coverage
pnpm test:coverage

# Run linting
pnpm lint

# Type checking
pnpm type-check
```

## Common Patterns

### 1. Service Pattern

```typescript
// All services should follow this pattern
export abstract class BaseService {
  protected logger: Logger;

  constructor(logger: Logger) {
    this.logger = logger;
  }

  abstract execute(...args: any[]): Promise<any>;

  protected handleError(error: Error): never {
    this.logger.error('Service execution failed', { error });
    throw error;
  }
}
```

### 2. Command Pattern

```typescript
// All commands should implement this interface
export interface Command<TArgs = any, TResult = void> {
  execute(args: TArgs): Promise<TResult>;
  validateArgs(args: TArgs): void;
  getHelp(): string;
}
```

### 3. Configuration Pattern

```typescript
// Use builder pattern for complex configurations
export class ConfigBuilder {
  private config: Partial<BaseConfig> = {};

  withPHP(version: string, extensions: string[]): this {
    this.config.php = { version, extensions };
    return this;
  }

  withSecurity(user: string, group: string): this {
    this.config.security = { user, group, nonRoot: true, readOnlyRoot: true };
    return this;
  }

  build(): BaseConfig {
    return this.validateAndBuild();
  }
}
```

## Troubleshooting

### 1. Common Issues

- **Type errors**: Ensure all types are properly defined
- **Performance issues**: Check for unnecessary operations in loops
- **Security warnings**: Verify all security features are enabled
- **Test failures**: Check test fixtures and mock data

### 2. Debug Mode

```typescript
// Enable debug logging for troubleshooting
const logger = new Logger({ level: 'debug' });
const service = new TemplateService(logger);
```

## Documentation Requirements

### 1. Code Documentation

- **JSDoc comments** for all public methods
- **Inline comments** for complex logic
- **README updates** for new features
- **API documentation** for public interfaces

### 2. User Documentation

- **Command help text** for all commands
- **Example configurations** in docs/
- **Troubleshooting guides** for common issues
- **Performance tuning** recommendations

## Remember

- **Always prioritize security** - no shortcuts
- **Performance matters** - optimize for CI/CD environments
- **Type safety is mandatory** - no `any` types without justification
- **Test everything** - high coverage is required
- **Follow the architecture** - don't deviate without discussion
- **Document as you go** - keep docs updated with code changes
